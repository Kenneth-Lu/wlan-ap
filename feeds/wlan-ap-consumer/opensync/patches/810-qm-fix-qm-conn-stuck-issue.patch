--- a/src/qm/qm_conn/src/qm_conn.c
+++ b/src/qm/qm_conn/src/qm_conn.c
@@ -44,6 +44,8 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 #define QM_SOCK_MAX_PENDING 10
 #define QM_COMPACT_SEND_SIZE (64*1024)
 
+static double qm_conn_default_timeout = QM_CONN_DEFAULT_TIMEOUT;
+
 extern const char *log_get_name();
 
 // server
@@ -100,6 +102,28 @@ bool qm_conn_accept(int listen_fd, int *
 
 // client
 
+void qm_conn_set_default_timeout(double timeout)
+{
+    qm_conn_default_timeout = timeout;
+}
+
+bool qm_conn_set_fd_timeout(int fd, double timeout)
+{
+    int ret;
+    struct timeval tv;
+    tv.tv_sec = (int)timeout;
+    tv.tv_usec = (int)((timeout - (int)timeout) * 1000000.0);
+    ret = setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, (const char*)&tv, sizeof tv);
+    if (ret != 0) goto error;
+    ret = setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, (const char*)&tv, sizeof tv);
+    if (ret != 0) goto error;
+    return true;
+error:
+    LOGE("setsockopt(%d,%f) = %d %d", fd, timeout, ret, errno);
+    return false;
+}
+
+
 bool qm_conn_client(int *pfd)
 {
     struct sockaddr_un addr;
@@ -115,6 +139,14 @@ bool qm_conn_client(int *pfd)
         return false;
     }
 
+    // set timeout; if 0 then never timeout
+    if (qm_conn_default_timeout > 0) {
+        if (!qm_conn_set_fd_timeout(fd, qm_conn_default_timeout)) {
+            close(fd);
+            return false;
+        }
+    }
+
     memset(&addr, 0, sizeof(addr));
     addr.sun_family = AF_UNIX;
     if (*path == '\0') {
--- a/src/qm/qm_conn/src/qm_conn.h
+++ b/src/qm/qm_conn/src/qm_conn.h
@@ -34,6 +34,7 @@ SOFTWARE, EVEN IF ADVISED OF THE POSSIBI
 
 #define QM_REQUEST_TAG "QREQ"
 #define QM_REQUEST_VER 2
+#define QM_CONN_DEFAULT_TIMEOUT 2.0 // timeout in seconds (float)
 
 enum qm_req_cmd
 {
@@ -141,6 +142,28 @@ bool qm_conn_accept(int listen_fd, int *
 bool qm_conn_server(int *pfd);
 bool qm_conn_client(int *pfd);
 
+/**
+ * @brief Set the qm_conn default timeout
+ *
+ * This overrides the default timeout of QM_CONN_DEFAULT_TIMEOUT
+ * If set to 0 then never timeout
+ *
+ * @param timeout timeout in seconds (float)
+ */
+void qm_conn_set_default_timeout(double timeout);
+
+/**
+ * @brief Set the qm_conn timeout for a specific session
+ *
+ * This overrides the qm_conn timeout for a specific session
+ * If set to 0 then never timeout
+ *
+ * @param fd qm_conn session
+ * @param timeout timeout in seconds (float)
+ */
+bool qm_conn_set_fd_timeout(int fd, double timeout);
+
+
 void qm_req_init(qm_request_t *req);
 bool qm_req_valid(qm_request_t *req);
 bool qm_conn_write_req(int fd, qm_request_t *req, char *topic, void *data, int data_size);
