From c9137e2ddf97ede1db399dc38acff26feb48ba7e Mon Sep 17 00:00:00 2001
From: David Bauer <mail@david-bauer.net>
Date: Sun, 14 Feb 2021 00:23:51 +0100
Subject: [PATCH] mediatek: add Ubiquiti LED driver

Add a driver for controlling the RGB LED via Ubiquitis own "LEDBAR" LED
controller based on the Holtek HT32F52241 MCU.

This driver is initially used by the Ubiquiti UniFi 6 LR, however
judging from FCC pictures the MCU is also found on the U6-Mesh as well
as the U6-Extender.

Signed-off-by: David Bauer <mail@david-bauer.net>
---
 .../files-5.4/drivers/leds/leds-ubnt-ledbar.c | 210 ++++++++++++++++++
 target/linux/mediatek/mt7622/config-5.4       |   1 +
 target/linux/mediatek/mt7623/config-5.4       |   1 +
 target/linux/mediatek/mt7629/config-5.4       |   1 +
 .../patches-5.4/1021-ubnt-ledbar-driver.patch |  29 +++
 5 files changed, 242 insertions(+)
 create mode 100644 target/linux/mediatek/files-5.4/drivers/leds/leds-ubnt-ledbar.c
 create mode 100644 target/linux/mediatek/patches-5.4/1021-ubnt-ledbar-driver.patch

diff --git a/target/linux/mediatek/files-5.4/drivers/leds/leds-ubnt-ledbar.c b/target/linux/mediatek/files-5.4/drivers/leds/leds-ubnt-ledbar.c
new file mode 100644
index 0000000000..1f50038b8c
--- /dev/null
+++ b/target/linux/mediatek/files-5.4/drivers/leds/leds-ubnt-ledbar.c
@@ -0,0 +1,210 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio/consumer.h>
+
+/**
+ * Driver for the Ubiquiti RGB LED controller (LEDBAR).
+ * This Controller is based on a Holtek HT32F52241 and connected
+ * via I2C.
+ *
+ *  - The Controller needs an enable signal set to high when
+ *    performing a transaction. On the U6-LR, this is located
+ *    at Pin 18 (R6902)
+ *
+ *  - The Pin is also printed when calling the "usetled" function
+ *    contained in the ubntapp bootloader application.
+ */
+
+#define UBNT_LEDBAR_MAX_BRIGHTNESS		0xff
+
+#define UBNT_LEDBAR_TRANSACTION_LENGTH	8
+#define UBNT_LEDBAR_TRANSACTION_SUCCESS	0xaa
+
+#define UBNT_LEDBAR_TRANSACTION_BLUE_IDX	2
+#define UBNT_LEDBAR_TRANSACTION_GREEN_IDX	3
+#define UBNT_LEDBAR_TRANSACTION_RED_IDX		4
+
+struct ubnt_ledbar {
+	struct mutex lock;
+	struct i2c_client *client;
+	struct led_classdev led_red;
+	struct led_classdev led_green;
+	struct led_classdev led_blue;
+	struct gpio_desc *enable_gpio;
+};
+
+static int ubnt_ledbar_perform_transaction(struct ubnt_ledbar *ledbar,
+					   char *transaction)
+{
+	int ret;
+	int i;
+
+	for (i = 0; i < UBNT_LEDBAR_TRANSACTION_LENGTH; i++)
+		i2c_smbus_write_byte(ledbar->client, transaction[i]);
+
+	return i2c_smbus_read_byte(ledbar->client);
+}
+
+static int ubnt_ledbar_apply_state(struct ubnt_ledbar *ledbar)
+{
+	char setup_msg[UBNT_LEDBAR_TRANSACTION_LENGTH] = {0x40, 0x10, 0x00, 0x00,
+							  0x00, 0x00, 0x00, 0x11};
+	char led_msg[UBNT_LEDBAR_TRANSACTION_LENGTH] = {0x40, 0x00, 0x00, 0x00,
+							0x00, 0x00, 0x01, 0x00};
+	char i2c_response;
+	int ret = 0;
+
+	mutex_lock(&ledbar->lock);
+
+	led_msg[UBNT_LEDBAR_TRANSACTION_BLUE_IDX] = ledbar->led_blue.brightness;
+	led_msg[UBNT_LEDBAR_TRANSACTION_GREEN_IDX] = ledbar->led_green.brightness;
+	led_msg[UBNT_LEDBAR_TRANSACTION_RED_IDX] = ledbar->led_red.brightness;
+
+	gpiod_set_raw_value(ledbar->enable_gpio, 1);
+
+	msleep(10);
+
+	i2c_response = ubnt_ledbar_perform_transaction(ledbar, setup_msg);
+	if (i2c_response != UBNT_LEDBAR_TRANSACTION_SUCCESS) {
+		dev_err(&ledbar->client->dev, "Error initializing LED transaction: %02x\n", ret);
+		ret = -EINVAL;
+		goto out_gpio;
+	}
+
+	i2c_response = ubnt_ledbar_perform_transaction(ledbar, led_msg);
+	if (i2c_response != UBNT_LEDBAR_TRANSACTION_SUCCESS) {
+		dev_err(&ledbar->client->dev, "Failed LED transaction: %02x\n", ret);
+		ret = -EINVAL;
+		goto out_gpio;
+	}
+
+	msleep(10);
+out_gpio:
+	gpiod_set_raw_value(ledbar->enable_gpio, 0);
+
+	mutex_unlock(&ledbar->lock);
+
+	return ret;
+}
+
+#define UBNT_LEDBAR_CONTROL_RGBS(name)				\
+static int ubnt_ledbar_set_##name##_brightness(struct led_classdev *led_cdev,\
+					enum led_brightness value)	\
+{									\
+	struct ubnt_ledbar *ledbar = \
+			container_of(led_cdev, struct ubnt_ledbar, led_##name); \
+	int ret; \
+	led_cdev->brightness = value; \
+	ret = ubnt_ledbar_apply_state(ledbar); \
+	return ret; \
+}
+
+UBNT_LEDBAR_CONTROL_RGBS(red);
+UBNT_LEDBAR_CONTROL_RGBS(green);
+UBNT_LEDBAR_CONTROL_RGBS(blue);
+
+
+static int ubnt_ledbar_init_led(struct device_node *np, struct ubnt_ledbar *ledbar,
+				struct led_classdev *led_cdev)
+{
+	struct led_init_data init_data = {};
+	int ret;
+
+	if (!np)
+		return 0;
+
+	init_data.fwnode = of_fwnode_handle(np);
+
+	led_cdev->max_brightness = UBNT_LEDBAR_MAX_BRIGHTNESS;
+
+	ret = devm_led_classdev_register_ext(&ledbar->client->dev, led_cdev,
+					     &init_data);
+	if (ret)
+		dev_err(&ledbar->client->dev, "led register err: %d\n", ret);
+
+	return ret;
+}
+
+
+static int ubnt_ledbar_probe(struct i2c_client *client,
+			     const struct i2c_device_id *id)
+{
+	struct device_node *np = client->dev.of_node;
+	struct ubnt_ledbar *ledbar;
+	int ret;
+
+	ledbar = devm_kzalloc(&client->dev, sizeof(*ledbar), GFP_KERNEL);
+	if (!ledbar)
+		return -ENOMEM;
+
+	ledbar->enable_gpio = devm_gpiod_get(&client->dev, "enable", GPIOD_OUT_LOW);
+
+	if (IS_ERR(ledbar->enable_gpio)) {
+		ret = PTR_ERR(ledbar->enable_gpio);
+		dev_err(&client->dev, "Failed to get enable gpio: %d\n", ret);
+		return ret;
+	}
+
+	gpiod_direction_output(ledbar->enable_gpio, 0);
+
+	ledbar->client = client;
+
+	mutex_init(&ledbar->lock);
+
+	i2c_set_clientdata(client, ledbar);
+
+	ledbar->led_red.brightness_set_blocking = ubnt_ledbar_set_red_brightness;
+	ubnt_ledbar_init_led(of_get_child_by_name(np, "red"), ledbar, &ledbar->led_red);
+
+	ledbar->led_green.brightness_set_blocking = ubnt_ledbar_set_green_brightness;
+	ubnt_ledbar_init_led(of_get_child_by_name(np, "green"), ledbar, &ledbar->led_green);
+
+	ledbar->led_blue.brightness_set_blocking = ubnt_ledbar_set_blue_brightness;
+	ubnt_ledbar_init_led(of_get_child_by_name(np, "blue"), ledbar, &ledbar->led_blue);
+
+	return ubnt_ledbar_apply_state(ledbar);
+}
+
+static int ubnt_ledbar_remove(struct i2c_client *client)
+{
+	struct ubnt_ledbar *ledbar = i2c_get_clientdata(client);
+
+	mutex_destroy(&ledbar->lock);
+
+	return 0;
+}
+
+static const struct i2c_device_id ubnt_ledbar_id[] = {
+	{ "ubnt-ledbar", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ubnt_ledbar_id);
+
+static const struct of_device_id of_ubnt_ledbar_match[] = {
+	{ .compatible = "ubnt,ledbar", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_ubnt_ledbar_match);
+
+static struct i2c_driver ubnt_ledbar_driver = {
+	.driver = {
+		.name	= "ubnt-ledbar",
+		.of_match_table = of_ubnt_ledbar_match,
+	},
+	.probe		= ubnt_ledbar_probe,
+	.remove		= ubnt_ledbar_remove,
+	.id_table	= ubnt_ledbar_id,
+};
+module_i2c_driver(ubnt_ledbar_driver);
+
+MODULE_DESCRIPTION("Ubiquiti LEDBAR driver");
+MODULE_AUTHOR("David Bauer <mail@david-bauer.net>");
+MODULE_LICENSE("GPL v2");
diff --git a/target/linux/mediatek/mt7622/config-5.4 b/target/linux/mediatek/mt7622/config-5.4
index ffebc43cb2..e92789697d 100644
--- a/target/linux/mediatek/mt7622/config-5.4
+++ b/target/linux/mediatek/mt7622/config-5.4
@@ -367,6 +367,7 @@ CONFIG_IRQ_FORCED_THREADING=y
 CONFIG_IRQ_TIME_ACCOUNTING=y
 CONFIG_IRQ_WORK=y
 CONFIG_JUMP_LABEL=y
+CONFIG_LEDS_UBNT_LEDBAR=y
 CONFIG_LIBFDT=y
 CONFIG_LOCK_DEBUGGING_SUPPORT=y
 CONFIG_LOCK_SPIN_ON_OWNER=y
diff --git a/target/linux/mediatek/mt7623/config-5.4 b/target/linux/mediatek/mt7623/config-5.4
index 06312ac03c..dbd3055d3b 100644
--- a/target/linux/mediatek/mt7623/config-5.4
+++ b/target/linux/mediatek/mt7623/config-5.4
@@ -295,6 +295,7 @@ CONFIG_JBD2=y
 CONFIG_KALLSYMS=y
 # CONFIG_KEYBOARD_MTK_PMIC is not set
 CONFIG_LEDS_MT6323=y
+# CONFIG_LEDS_UBNT_LEDBAR is not set
 CONFIG_LIBFDT=y
 CONFIG_LOCK_DEBUGGING_SUPPORT=y
 CONFIG_LOCK_SPIN_ON_OWNER=y
diff --git a/target/linux/mediatek/mt7629/config-5.4 b/target/linux/mediatek/mt7629/config-5.4
index 82ef4996af..7fe01d1748 100644
--- a/target/linux/mediatek/mt7629/config-5.4
+++ b/target/linux/mediatek/mt7629/config-5.4
@@ -214,6 +214,7 @@ CONFIG_IRQ_FORCED_THREADING=y
 CONFIG_IRQ_TIME_ACCOUNTING=y
 CONFIG_IRQ_WORK=y
 # CONFIG_LEDS_BRIGHTNESS_HW_CHANGED is not set
+# CONFIG_LEDS_UBNT_LEDBAR is not set
 CONFIG_LIBFDT=y
 CONFIG_LOCK_DEBUGGING_SUPPORT=y
 CONFIG_LOCK_SPIN_ON_OWNER=y
diff --git a/target/linux/mediatek/patches-5.4/1021-ubnt-ledbar-driver.patch b/target/linux/mediatek/patches-5.4/1021-ubnt-ledbar-driver.patch
new file mode 100644
index 0000000000..c971b9b4ca
--- /dev/null
+++ b/target/linux/mediatek/patches-5.4/1021-ubnt-ledbar-driver.patch
@@ -0,0 +1,29 @@
+--- a/drivers/leds/Kconfig
++++ b/drivers/leds/Kconfig
+@@ -823,6 +823,16 @@ config LEDS_LM36274
+ 	  Say Y to enable the LM36274 LED driver for TI LMU devices.
+ 	  This supports the LED device LM36274.
+ 
++config LEDS_UBNT_LEDBAR
++	tristate "LED support for Ubiquiti UniFi 6 LR"
++	depends on LEDS_CLASS && I2C && OF
++	help
++	  This option enables support for the Ubiquiti LEDBAR
++	  LED driver.
++
++	  To compile this driver as a module, choose M here: the module
++	  will be called leds-ubnt-ledbar.
++
+ comment "LED Triggers"
+ source "drivers/leds/trigger/Kconfig"
+ 
+--- a/drivers/leds/Makefile
++++ b/drivers/leds/Makefile
+@@ -85,6 +85,7 @@ obj-$(CONFIG_LEDS_LM3601X)		+= leds-lm36
+ obj-$(CONFIG_LEDS_TI_LMU_COMMON)	+= leds-ti-lmu-common.o
+ obj-$(CONFIG_LEDS_LM3697)		+= leds-lm3697.o
+ obj-$(CONFIG_LEDS_LM36274)		+= leds-lm36274.o
++obj-$(CONFIG_LEDS_UBNT_LEDBAR)	+= leds-ubnt-ledbar.o
+ 
+ # LED SPI Drivers
+ obj-$(CONFIG_LEDS_CR0014114)		+= leds-cr0014114.o
-- 
2.27.0

